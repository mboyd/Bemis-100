#!/usr/bin/env python2.6
from __future__ import division

import pattern as bp
import spectrogram as sp
import beat as beatp
import serial
import time, sys, os
from optparse import OptionParser
import pygame
from pygame.locals import *
from multiprocessing import *
import threading
import copy

import pdb

'''This program is the main control system for the Bemis100. It takes a pattern
generated by pattern.py and displays it on the system. It can also
simulate the Bemis100 using pygame.'''

class Bemis100:
    def __init__(self, device, num_boards=83, framerate=30):
        self.num_boards = num_boards
        self.frame_dt = 1.0 / framerate
        self.device = device
        
        if self.device == 'sim':
            self.writer = SimWriteThread('', num_boards, framerate)
        else:
            self.writer = WriteThread(device, num_boards, framerate)
        
        self.play, self.pause, self.is_playing, self.next = \
            self.writer.play, self.writer.pause, self.writer.is_playing, self.writer.next
        
        self.writer.start()
                
    def blank(self):
        '''Turn off all the LEDs. We do this before startup to make sure the
        power supplies are not loaded by the LEDs when they come online.'''
        p = [bytearray("\x00\x00\x00"*self.num_boards*2)]
        self.draw_pattern(p, num_times=1, async=False)
    
    def draw_pattern(self, pattern, num_times=-1, async=True):
        '''Draw the current pattern a given number of times. We write pixel
        brightness values to the Bemis100, which handles the PWM generation in
        the microcontroller firmware.'''
        
        print 'Adding pattern'
        self.writer.add_pattern(pattern, num_times)
        self.writer.play()
        
        if not async:
            print 'Waiting on writer to finish'
            self.writer.wait_for_finish()
            print 'Writer done'
    
    def quit(self):
        self.draw_pattern(None)
            
class WriteThread(Process):
    
    def __init__(self, device, num_boards, framerate):
        Process.__init__(self)
        
        self.device = device
        self.port = None
        self.num_boards = num_boards
        self.frame_dt = 1.0 / framerate
        
        self.play_queue = JoinableQueue()
        
        
        ### CONTROL MUTEXES
        
        self._play = Event()    # Continue playing; if not set, enter pause mode, 
                                # staying on the same pattern
        
        self._next = Event()    # If set, skip to the next pattern
    
    def add_pattern(self, pattern, num_times):
        self.play_queue.put_nowait((pattern, num_times))
    
    def play(self):
        self._play.set()
    
    def pause(self):
        self._play.clear()
    
    def is_playing(self):
        return self._play.is_set()
    
    def next(self):
        self._next.set()
    
    def wait_for_finish(self):
        if not self.is_alive():
            raise SystemExit
        self.play_queue.join()
        

    def run(self):
        self.open_port()
        
        try:
            while True:
                pattern, num_times = self.play_queue.get()
                
                if pattern is None:
                    self.play_queue.task_done()
                    sys.exit(0)
                
                self.draw_pattern(pattern, num_times)
                self.play_queue.task_done()
        
        except KeyboardInterrupt:
            pass
        
    
    def draw_pattern(self, pattern, num_times):
        count = 0
        while self._play.is_set():
            if (num_times > 0 and count == num_times):
                print 'Draw finished, breaking'
                break
                        
            for row in pattern:
                if not self._play.is_set():
                    print 'Paused, waiting'
                    self._play.wait()
                
                if self._next.is_set():
                    print 'Skipping to next pattern'
                    self._next.clear()
                    return
                                
                row_start = time.time()
                
                self.draw_frame(row)
                
                dt = time.time() - row_start
                if dt < self.frame_dt:
                    time.sleep(self.frame_dt - dt)
            count += 1
    
    def open_port(self):
        self.port = serial.Serial(port=self.device,
                baudrate=230400,
                bytesize=serial.EIGHTBITS,
                stopbits=serial.STOPBITS_ONE,
                parity=serial.PARITY_NONE,
                timeout=0.5,
                writeTimeout=0)

    def close_port(self):
        self.blank();
        self.port.close()

    def draw_frame(self, frame):
        self.port.write('B')
        self.port.write(frame)
   
class SimBemis100(Bemis100):
    def __init__(self, num_boards=83, framerate=30):
        Bemis100.__init__(self, 'sim', num_boards, framerate)

class SimWriteThread(WriteThread):
    '''A simulated Bemis100, implemented in pygame. Most of its functions are
    carried over from Bemis100.'''

    def open_port(self):
        self.num_pixels = self.num_boards * 2
        self.frame = [0 for i in range(self.num_boards * 6)]
        self.index = 0
        
        pygame.init()
        pygame.event.set_allowed(None)
        pygame.event.set_allowed(pygame.QUIT)
        
        pixelWidth = 5 # Screen pixels per Bemis100 pixel
        width = pixelWidth * self.num_pixels
        pixelHeight = 50
        height = pixelHeight
        size = width, height
        self.screen = pygame.display.set_mode(size)
        self.pixels = [pygame.Rect(i*pixelWidth,0,pixelWidth,pixelHeight) for i\
                in range(self.num_pixels)]
    
    def draw_frame(self, frame):
        for i in range(0, len(frame), 3):
            r, g, b = map(decode_char, frame[i:i+3])
            color = pygame.Color(r, g, b, 1)
            pygame.draw.rect(self.screen,color,  self.pixels[int(i/3)])
        
        pygame.display.flip()
        for evt in pygame.event.get():
            if evt.type == pygame.QUIT:
                pygame.quit()
                raise SystemExit
    

def decode_char(x):
    '''Undo the conversion from char values to bytes, in which the value is
    indicated by the number of 1s in the byte'''
    return int(bin(x).count('1') * 255/8)

if __name__ == '__main__':
    p = OptionParser("Usage: python %prog [pattern | pattern_dir] [options]")
    
    p.add_option('-n', type="int", action='store', dest='num_boards', 
                    default='83', help='Number of boards (default 83)')
    
    p.add_option('-d', action="store", dest="device", default="", 
                    help="Device path")
    
    p.add_option('-f', type='int', action='store', dest='framerate', 
                    default='30', help='Framerate (Hz, default 30)')
                    
    p.add_option('-r', action='store_true', dest='repeat', default=False,
                    help="Repeat pattern[s] forever")
    
    p.add_option('-c', type='int', action='store', dest='count',
                    default='-1', 
                    help='Repetition count (exit when done, default is to loop forever)')
    
    p.add_option('-s','--sim', action='store_true', dest='sim',default=False,
                    help='Simulate the Bemis100 only')

    p.add_option('-b','--rainbow', action='store_true', dest='rainbow',default=False,
            help='Rainbow beat pattern')

    p.add_option('-w','--wave', action='store_true',dest='wave',default=False,
                 help='Wave beat pattern')
    
    (options, args) = p.parse_args()

    
    if len(args) < 1 and not (options.rainbow or options.wave):
        p.print_help()
        sys.exit(1)
        
    patterns = []
    
    if options.rainbow or options.wave:
        patterns = [None]
    else:
        if os.path.isfile(args[0]):
            patterns.append(args[0])
        elif os.path.isdir(args[0]):
            patterns.extend([os.path.join(args[0], fn) for fn in os.listdir(args[0])])
        else:
            print "Not a pattern file or directory: %s\n\n" % args[0]
            p.print_help()
            sys.exit(1)
        
    print "Opening port...",
    
    if not options.sim:
        if options.device == '':
            devices = filter(os.path.exists, ['/dev/tty.usbserial', '/dev/ttyUSB0'])
            if len(devices) > 0:
                options.device = devices[0]
        
        b = Bemis100(options.device, options.num_boards, options.framerate)
    else:
        b = SimBemis100(options.num_boards, options.framerate)
    
    print "done\nLooping...",
    sys.stdout.flush()
    
    while True:
        for fn in patterns:
            if options.rainbow:
                pattern = beatp.BeatPattern()
            elif options.wave:
                pattern = sp.SpectrogramPattern()
            else:
                pattern = bp.Bemis100Pattern(fn, options.num_boards)
            b.blank()
            
            try:
                b.draw_pattern(pattern, num_times=options.count, async=False)
                print 'Draw returned'
            except KeyboardInterrupt:
                print "\b\b\b",
                print "done"
                b.stop()
                b.blank()
                sys.exit(0)
            
        if not options.repeat:
            b.draw_pattern(None)
            break
