#!/usr/bin/env python2.6
from __future__ import division

import bemis_100_pattern as bp
import spectrogram_pattern as sp
import beat_pattern as beatp
import serial
import time, sys, os
from optparse import OptionParser
import pygame
from pygame.locals import *


'''This program is the main control system for the Bemis100. It takes a pattern
generated by bemis_100_pattern.py and displays it on the system. It can also
simulate the Bemis100 using pygame.'''

class Bemis100:

    def __init__(self, device, num_boards=83, framerate=30):
        self.num_boards = num_boards
        self.frame_dt = 1.0 / framerate
        self.device = device
    
    def open_port(self):
        self.port = serial.Serial(port=self.device,baudrate=230400,
                bytesize=serial.EIGHTBITS,
                stopbits=serial.STOPBITS_ONE,
                parity=serial.PARITY_NONE,
                timeout=0.5,
                writeTimeout=0)
        self.blank()
                
    def blank(self):
        '''Turn off all the LEDs. We do this before startup to make sure the
        power supplies are not loaded by the LEDs when they come online.'''
        self.port.write('B'+"\x00\x00\x00"*self.num_boards*2)
    
    def draw_pattern(self, pattern, num_times=-1):
        '''Draw the current pattern a given number of times. We write pixel
        brightness values to the Bemis100, which handles the PWM generation in
        the microcontroller firmware.'''
        count = 0
        i = 0
        while True:
            if (num_times > 0 and count == num_times):
                break
            
            for row in pattern:
                row_start = time.time()
                                
                self.port.write('B')
                self.port.write(row)
                
                dt = time.time() - row_start
                if (self.frame_dt - dt) > 0:
                    time.sleep(self.frame_dt-dt)
            count += 1
   

class SimBemis100(Bemis100):
    '''A simulated Bemis100, implemented in pygame. Most of its functions are
    carried over from Bemis100.'''
    def __init__(self, device, num_boards=6, framerate=10):
        self.num_boards = num_boards
        self.frame_dt = 1.0 / framerate

    def open_port(self): 
        self.port = SimPort(self)
        self.num_pixels = self.num_boards * 2
        self.frame = [0 for i in range(self.num_boards * 6)]
        self.index = 0
        
        pygame.init()
        pixelWidth = 5 # Screen pixels per Bemis100 pixel
        width = pixelWidth * self.num_pixels
        pixelHeight = 50
        height = pixelHeight
        size = width,height
        self.screen = pygame.display.set_mode(size)
        self.pixels = [pygame.Rect(i*pixelWidth,0,pixelWidth,pixelHeight) for i\
                in range(self.num_pixels)]

    def write(self, b):
        if b == 'B' or b == ord('B') :
            self.index = 0
            self.draw()
        else:
            self.frame[self.index] = decode_char(b)
            self.index += 1

    def blank(self):
        pass
    
    def draw(self):
        for i in range(0,len(self.frame),3):
            color=pygame.Color(self.frame[i],self.frame[i+1],self.frame[i+2],1)
            pygame.draw.rect(self.screen,color,  self.pixels[int(i/3)])
        pygame.display.flip()

class SimPort:
    '''A fake port for use with the SimBemis100. This construction is used to
    allow transparent interface with the normal Bemis100 code.'''
    def __init__(self,sb):
        self.sb = sb
    
    def write(self, data):
        try:
            for b in data:
                self.sb.write(b)
        except TypeError:   # Not iterable
            self.sb.write(data)

def decode_char(x):
    '''Undo the conversion from char values to bytes, in which the value is
    indicated by the number of 1s in the byte'''
    return int(bin(x).count('1') * 255/8)

if __name__ == '__main__':
    p = OptionParser("Usage: python %prog [pattern | pattern_dir] [options]")
    
    p.add_option('-n', type="int", action='store', dest='num_boards', 
                    default='83', help='Number of boards (default 83)')
    
    p.add_option('-d', action="store", dest="device", default="", 
                    help="Device path")
    
    p.add_option('-f', type='int', action='store', dest='framerate', 
                    default='30', help='Framerate (Hz, default 30)')
                    
    p.add_option('-r', action='store_true', dest='repeat', default=False,
                    help="Repeat pattern[s] forever")
    
    p.add_option('-c', type='int', action='store', dest='count',
                    default='-1', 
                    help='Repetition count (exit when done, default is to loop forever)')
    
    p.add_option('-s','--sim', action='store_true', dest='sim',default=False,
                    help='Simulate the Bemis100 only')

    p.add_option('-a', action='store', dest='audio',default=None,
            help='Run audio tracking (default is "rainbow" pattern)')
    
    (options, args) = p.parse_args()

    
    if len(args) < 1 and not options.audio:
        p.print_help()
        sys.exit(1)
        
    patterns = []
    
    if options.audio:
        patterns = [None]
    else:
        if os.path.isfile(args[0]):
            patterns.append(args[0])
        elif os.path.isdir(args[0]):
            patterns.extend([os.path.join(args[0], fn) for fn in os.listdir(args[0])])
        else:
            print "Not a pattern file or directory: %s\n\n" % args[0]
            p.print_help()
            sys.exit(1)
        
    if not options.sim:
        
        
        
        b = Bemis100(options.device, options.num_boards, options.framerate)
    else:
        b = SimBemis100(options.device, options.num_boards, options.framerate)
        
    print "Opening port...",
    b.open_port()
    
    print "done\nLooping...",
    sys.stdout.flush()
    
    while True:
        for fn in patterns:
            if options.audio:
                if options.audio == 'rainbow':
                    pattern = beatp.BeatPattern()
                else:
                    pattern = sp.SpectrogramPattern()
            else:
                pattern = bp.Bemis100Pattern(fn, options.num_boards)
            b.blank()
            
            try:
                b.draw_pattern(pattern, num_times=options.count)
            except KeyboardInterrupt:
                print "\b\b\b",
                print "done"
                b.blank()
                sys.exit(0)
            
        if not options.repeat:
            break
